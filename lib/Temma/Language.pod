=head1 NAME

Temma::Language - Temma template markup language

=head1 SYNOPSIS

  <!DOCTYPE html>
  <html lang=en t:params=$paras>
  <title>A Temma template</title>
  
  <h1>Temma language</h1>
  
  <t:for as=$para x=$paras>
    <p><t:text value=$para>
  </t:for>

=head1 DESCRIPTION

The B<Temma markup language> is an HTML-based template document format
for generating HTML or plain text documents.  This document describes
the syntax and semantics of the markup language.

The language and its processing model is defined in terms of DOM tree.
Syntactical components of the template is represented as DOM nodes in
the document.  There is the serialized format for the language, whose
syntax is mostly inspired by HTML serialization format of the HTML
language.  The B<Temma parser> is a software component to read the
serialized format into the DOM representation of the Temma markup
language.  The B<Temma processor> is a software component to convert
DOM of the source (template) document into result document.

 +---------------------+  <!DOCTYPE html>
 | Source document     |  <html t:params=$foo>
 | (template)          |  <title>Test</title>
 | in Temma syntax     |  <p><t:text value=$foo>
 +---------------------+
           |
           | Parse
           v
 +---------------------+  #document
 | DOM of source       |   +- html
 | (template) document |    +- head - title - #text
 +---------------------+    +- body - p - t:text
           |
           | Process
           v
 +---------------------+  #document
 | DOM of              |   +- html
 | result document     |    +- head - title - #text
 +---------------------+    +- body - p - #text
           |
           | Serialize
           v
 +---------------------+  <!DOCTYPE html>
 | Result document     |  <html><head><title>Test</title></head>
 | in HTML syntax      |  <body><p>Paragraph.</p></body></html>
 +---------------------+

=head1 Basic rules and handling of HTML nodes

The Temma syntax shares most syntax and parsing rules with the HTML
syntax.  That is, most of conforming HTML documents result in same DOM
tree by both HTML and Temma parsers.  (See
<http://www.whatwg.org/specs/web-apps/current-work/#syntax> for
details of the HTML syntax.)

The document node created by the Temma parser is marked as an HTML
document for the purpose of DOM
<http://dom.spec.whatwg.org/#html-document>.  (This may affect
conformance of the document.  For example, the C<lang> attribute
rather than the C<xml:lang> attribute must be used to encode the
language of an HTML element.)

Nodes in the source (i.e. template) document are processed in document
order to generate the result document.

The document node in the source document generates the document node
in the result document and its child nodes are processed to generate
children of the result document.

The source document may contain the DOCTYPE whose name is C<html>.
This is optional; the Temma parser implies the DOCTYPE anyway.  The
document type node in the source document generates the document type
node in the result document with same name.

HTML, SVG, and MathML element nodes in the source document result in
element nodes with same namespace and local name in the result
document, and their attributes and child nodes are also processed to
generate attributes and children of the result element.

The document element (or root element of the document) must be the
HTML C<html> element.

As in the HTML syntax, some of start and end tags can be omitted in
the Temma syntax.  Although how omissions are interpreted by the Temma
parser differs from the HTML parser in several ways, as long as
conforming document fragment goes, both HTML and Temma parser should
generate same DOM tree for an input.

Example.  Two lines below are equivalent:

  <!DOCTYPE html><title>fuga</title><p>hoge<p>hoge
  <!DOCTYPE html><html><head><title>fuga</title><body><p>hoge</p><p>hoge</p></body></html>

For the source element in HTML, SVG, or MathML namespace, any
attribute with no namespace, or in C<xml:>, C<xmlns:>, or C<xlink:>
namespace, generates an attribute with same namespace, local name, and
value, for the result element generated by the source element.

Example.  A template:

  <html lang=ja><title>Hello</title><p title="A paragraph.">Hello, world!

... generates the following result document:

  <!DOCTYPE html><html lang="ja"><head><title>Hello</title></head>
  <body><p title="A paragraph.">Hello, world!</p></body></html>

The Temma syntax does not support XML Namespaces, but there are
namespace prefix syntax for embedding Temma template instructions.
For example, tag name C<t:if> represents the C<if> element in the
Temma namespace.  Likewise, attribute name C<m:param1> represents the
C<param1> attribute in the Temma macro namespace.  There are following
namespace prefixes:

  t:      Temma namespace
  m:      Temma macro namespace
  msg:    Temma text message namespace
  pl:     Temma Perl code namespace

The tag name of the end tag can be omitted if the tag closes the most
recently opened element and if the element is not one of C<title>,
C<textarea>, C<style>, and C<script>.

Example: Following lines are equivalent:

  <p>abc<span>xx</></>
  <p>abc<span>xx</span></p>

The local name part of the end tag can be omitted if the tag name has
a namespace prefix.

Example: Following lines are equivalent:

  <msg:my.text-1><p>Value</msg:>
  <msg:my.text-1><p>Value</msg:my.text-1>
  <msg:my.text-1><p>Value</></t:></msg:>
  <msg:my.text-1><t:field><p>Value</p></t:field></msg:my.text-1>

=head1 Processing of element content

The content of a source element is processed in document order.  A
text node might generate text node in the result document.  An element
in HTML, SVG, or MathML namespace generates an element in the result
document.  An element in Temma or Temma macro namespace is handled by
their processing rules.  Other types of nodes, including comment,
CDATA section, and processing instruction nodes, are ignored.

Void elements in the HTML syntax are also void elements in the Temma
syntax, i.e. their end tags must be omitted.

Example.  Following elements cannot have end tags and contents:

  <br>
  <img src="foo.png" alt="Foo Image">

Unlike the HTML syntax, the polytheistic slash syntax can be used to
represent an element with no content, even for HTML elements.  This
cannot be overridden by the C<t:parse> attribute described in the
following subsection.

Example.  Two lines below are equivalent:

  <div/><svg><g/></svg><p/><br/>
  <div></div><svg><g></g></svg><p></p><br>

As in the HTML syntax, no child element is allowed within following
HTML elements: C<title>, C<textarea>, C<style>, and C<script>.

Example.  The following C<script> element contains only a text node:

  <script> document.getElementById ('hoge').innerHTML = '<p>hoge</p>' </script>

Character references allowed in the HTML syntax are also allowed in
element content and attribute value of the Temma syntax, except for
content of C<style> and C<script> elements.

Examples.  Following lines represent paragraphs with same text, i.e. a
string with 5 characters, C<Q & A>:

  <p>Q & A</p>
  <p>Q &amp; A</p>
  <p>Q &#x26; A</p>
  <p>Q &#38; A</p>

... but the following script contains string literal with 9 characters
C<Q &amp; A>.

  <script>var a = 'Q &amp; A';</script>

=head2 Attribute t:parse=""

Any element may have C<t:parse=""> boolean attribute to override
element-dependent special content parsing behavior.  If the attribute
is specified for the element, its content is parsed in the same way as
a normal element, i.e. child elements and character references are
recognized and the end tag is required for the void element.

Example.  The following C<title> element contains a C<t:text> element
as a child:

  <title t:parse>
    <t:text value=" $title "> - My Web site
  </title>

If there were no C<t:parse> attribute, the C<t:text> tag is
interpreted as part of the only text node in the C<title> element (the
C<< < >> character is interpreted as part of the text).

Example.  The following C<img> element contains a C<t:attr> element as
a child:

  <img t:parse>
    <t:attr name="'src'" value=$image_url>
    <t:attr name="'alt'" value=$image_text>
  </img>

=head1 Evaluation of Perl code

Some of attributes is defined as Perl expression attributes.  Their
values are evaluated during the processing of the template.

A Perl expression attribute value is evaluated as if it were enclosed
by a Perl block (i.e. C<do { ... };>) and under the C<use strict; use
warnings;> pragmata.  Since each attribute value is evaluated
independently, any lexical variable declared within an attribute
cannot be used in another attribute.  As all Perl expressions in the
template is evaluated in the context of a specific (dynamically
generated) package, attributes can share a variable by using the
C<our> statement:

  <!-- ! This is not the preferred way to share a variable ! -->
  <t:call x="our $hoge = 124">
  <t:text value="our $hoge">

However, the C<t:my> element as described in the next subsection is
the preferred way to share variables among multiple Perl expression
attributes.  Values set to C<our> variables will not be destroyed
until the entire script exits, while lexical variables declared by the
C<t:my> element will be destroyed once the processing goes outside of
the scope.

Most of Perl expression attributes are expected to return a value.  If
the code explicitly return a value by the C<return> statement, it is
the value returned by the expression.  Otherwise, the last evaluated
value is the returned value.  When a string value is expected to be
returned, it must be a character string.  In other word, if the string
contain a character greater than U+00FF, the string must be
utf8-flagged.

=head2 <t:my as="{varname}" [x="{expr}"]>

The C<t:my> element declares a lexical variable.  The C<t:my> element
is a void element, i.e. it has no end tag by default.  The C<t:my>
element may be inserted anywhere in the document.

The C<as> attribute is required.  Its value must be a valid variable
name specification, i.e. a string matching the regular expression
C<\$[A-Za-z][A-Za-z0-9_]*> but not C<$_>.  The C<$> prefix may be
omitted.  The C<as> attribute is the variable name to be declared.

The C<x> attribute is a Perl expression attribute.  If specified, the
evaluated value of the attribute is assigned to the variable declared
by the element.  Otherwise, the C<undef> value is assigned.

The scope of the variable declared by the C<t:my> element is the
following sibling nodes and their children, except for any descendant
C<t:macro> element and its children.

Example.

  <div>
    <t:text value=" $foo * 1 "><!-- Syntax error -->
    <t:my as=$foo value=120>
    <t:text value=" $foo * 2 "><!-- 240 -->
    <p>
      <t:text value=" $foo * 3 "><!-- 360 -->
      <t:my as=$foo value=50>
      <t:text value=" $foo * 4 "><!-- 200 -->
  </div>
  <t:text value=" $foo * 5 "><!-- Syntax error -->

=head2 <t:call x="{expr}">

The C<t:call> element can be used to invoke a Perl code fragment
without using its result.  The element may be used anywhere in the
C<html> element (or its descendant).  The C<t:call> element is a void
element, i.e. it has no end tag by default.

The C<x> attribute is a Perl expression attribute.  The C<x> attribute
is required.  The Perl expression is evaluated when the element is
processed.  Otherwise the element does nothing.

=head1 Generating nodes in result document

As decribed in previous sections, HTML element nodes and text nodes
generate elements and texts in result document.  In addition,
following Temma elements can be used to generate nodes whoes values
are partially determined by evaluating Perl code.

=head2 <t:element name="{expr}">{content}</t:element>

The C<t:element> element generates an element, whose tag name is given
by the C<name> attribute.  The element may be used anywhere within the
HTML C<head> and C<body> elements (and their children) where child
elements are allowed in the result document.  The content of the
C<t:element> element is processed to generate the content of the
element.

The C<t:element> element must have the C<name> attribute, which is a
Perl expression attribute.  The expression must return a valid tag
name or the C<undef> value.

If the C<name> attribute is evaluated to a tag name, an element with
the tag name is generated.  The namespace of the generated element
depends on the nearest ancestor element which is not in the Temma
namespace in the source document.

Example.

  <svg>
    <t:element name="'g'">
      <circle/>
    </t:element>
  </svg>

The C<t:element> in the template fragment above generates an SVG C<g>
element as its parent element belongs to the SVG namespace.

If the C<name> attribute is evaluated to the C<undef> value, then no
element is generated from the C<t:element> element, although its
content is processed as if it were content of a normal element.  Any
C<t:attr> or C<t:class> child elements at the beginning of the
children list of the C<t:element> is ignored.

Example.

  <p>
    <t:element name=" defined $obj->url ? 'a' : undef ">
      <t:attr name="'href'" value=" $obj->url ">
      <t:text value=" $obj->label ">
    </t:element>

This template generates a paragraph whose content is the label of the
given object.  The label is linked to the URL of the object, if any,
using the HTML C<a> element:

  <p><a href="http://my.example.com/">Top page</a></p>

Otherwise, the label is directly contained within the C<p> element:

  <p>This page</p>

Note that the C<t:attr> element is ignored if the C<t:element> element
generates no element.  Also note that white space characters before
and after C<t:text> element are ignored even when the C<t:element>
element generates no element.

The C<t:element> element cannot be used to generate C<html>, C<head>,
or C<body> element.

=head2 <t:attr name="{expr}" value="{expr}"> and attribute pl:{name}="{expr}"

The C<t:attr> element generates an attribute for the result element
generated by the nearest ancestor source element generating an
element.  The C<t:attr> element may be placed as a child of any
element, but it must be placed before any text node containing non
white space character or any node generating an element, text, or
comment node.  The C<t:attr> element is a void element, i.e. it has no
end tag by default.

The C<name> attribute is a Perl expression attribute.  The attribute
is required.  The expression must return a valid attribute name.

The C<value> attribute is a Perl expression attribute.  The attribute
is required.  The expression must return a string, possibly empty.

Example.

  <p onclick=" alert (1) ">
    <t:if x="defined $title">
      <t:attr name="'title'" value="$title">
    </t:if>
    <t:attr name="'id'" value="$id">
    Hello!
  </p>

If the template above is evaluated with appropriate C<$title> and
C<$id> values, result fragment would be as follows:

  <p onclick=" alert (1) " title="Title." id="para1">Hello!</p>

The C<pl:{name}> attribute, where {name} is the attribute local name,
can also be used to generate an attribute for the result element
generated by the nearest ancestor source element generating an
element.  It may be specified for an element which generates an
element.  It is a Perl expression attribute.  The expression must
return a string, which is used as the value of the result attribute.

Attributes generated by C<t:attr> elements, as well as attributes
generated by C<pl:{name}> attributes and C<msg:{name}> attributes
(described in later section) are merged together with attributes
generated by attributes of the source element and result in the
generated element for them.  There must not be duplicate attribute
names (except for the C<class> attribute, as decribed in the next
subsection).

=head2 <t:class name="{expr}">

The C<t:class> element specifies class names for the element generated
by the nearest ancestor source element which generates an element.
The C<t:class> element must be placed before any other element or non
white space character is generated.  The C<t:class> element is void
element, i.e. end tag is not allowed in general.

The C<t:class> element specifies a class name for the result element
generated by the nearest ancestor source element generating an
element.  The C<t:class> element may be placed anywhere the C<t:attr>
element can be placed.  The C<t:class> element is a void element,
i.e. it has no end tag by default.

Unlike other attributes, the C<class> attribute is handled specially.
There may be more than one of the C<class> source attribute, C<t:attr>
elements generating C<class> attributes, and C<t:class> elements, for
a single result element.  Their values must be space-separated lists
of zero or more class names.  They are used to generate a single
C<class> attribute for the result element.

Example.

  <p class="default global">
    <t:if x=$selected>
      <t:class name='"selected"'>
    </t:if>
    <t:attr name="'class'" value="'para-' . $level">
    Paragraph.

This template fragment would generate the following HTML fragment (if
there are appropriate variable assignments):

  <p class="default global selected para-4">Paragraph.</p>

=head2 <t:text value="{expr}">

The C<t:text> element generates a text node with the specified value.
in general.  The element can be placed as child or descendant of
metadata content or the HTML C<body> element.  The C<t:text> element
is a void element, i.e. it has no end tag by default.

The C<value> attribute is required.  The C<value> attribute is a Perl
expression attribute.  The expression must return a string.

As the element generates a text node, not just string used as element
content in the HTML syntax, the returned string don't have to be
HTML-escaped.  Characters are automatically escaped, if necessary,
when the result document is serialized in the HTML syntax.

Example.

  <p><t:text value="'See also <Q & A> section.'">

... generates:

  <p>See also &lt;Q &amp; A&gt; section.</p>

=head2 <t:comment>{content}</t:comment>

The C<t:comment> element generates a comment node in the result
document.  This element can be used anywhere in the C<html> element
(or its descendant).

Any real comment node in the source document is ignored, i.e. not
appers in the result document.  Real comment syntax is expected to be
used as notes for template authors.  Instead, the C<t:comment> element
can be used to generate comments for the result document.

The C<t:comment> element may contain any node, but it must only
generate one or more characters.  In particular, there must not be an
element generating elements, attributes, or comments.

Comments in the HTML syntax cannot contain substring C<-->.  If the
C<t:comment> element's content generates a string containing C<--> or
ends by C<->, a space character is inserted just after each C<->
character.

Example.

  <p>
  <!-- The following element generates a comment -->
  <t:comment>
    <t:text value="'Comment1 -- Comment2'">
  </t:comment>

... generates:

  <p><!--Comment1 - -  Comment2--></p>

=head2 <t:barehtml value="{expr}">

The C<t:barehtml> element is special in that it does not generate a
node in the result document tree but it generates a bare HTML
fragment, i.e. a sequence of HTML tags, comments, character
references, CDATA sections (in foreign content), and other characters,
to be embedded in the result document serialized in the HTML syntax.

The element can be placed as child or descendant of metadata content
or the HTML C<body> element.  The C<t:barehtml> element is a void element,
i.e. it has no end tag by default.

The C<value> attribute is required.  The C<value> attribute is a Perl
expression attribute.  The expression must return a string, which is
expected to be an HTML fragment valid in the context of the position
the fragment is inserted in the result document.

This element should not be used, as the rules to construct the HTML
node structure of the result document should be fully described by the
Temma language, not in random Perl logic.  (This is the Separation of
Concerns principle for the Temma template processing, for
maintenancebility, security, and syntactical soundness.)  Neverthless
this element is provided such that something already formatted in
HTML, e.g. Markdown-converted HTML fragment or HTML document fragment
from external data source, can be easily integrated with the rest of
template.

Currently, the returned HTML fragment is inserted to the result
document as is, without any parsing.  This behavior is subject to
future change and the author should not rely on the current behavior.

=head2 Attribute t:space="{keyword}"

The C<t:space> attribute may be specified to any element.  The
attribute is an enumerated attribute whose keywords are C<preserve>
and C<trim>.  The attribute specifies how the white space in the
element content is handled.  The C<preserve> keyword maps to the
preserve state.  The C<trim> keyword maps to the trim keyword.  In
addition, there is a third state, the default state, which is the
missing value default.

By default, leading and trailing white space characters in an element
is ignored and do not appear in the result document.  Elements
C<t:attr> and C<t:if> are ignored for the purpose of detection of
leading and trailing white space characters.  However, this behavior
is not applied to HTML C<pre> and C<textarea> elements.  This white
space handling can be overridden by specifying the C<t:space>
attribute.

The preserve state of the C<t:space> attribute indicates that the
leading and trailing white space characters in an element generates
the same sequence of characters in the result document.  The trim
state indicates that the leading and white space characters in an
element should be ignored such that they do not apper in the result
document.  The default state indicates that, if the element is the
HTML C<pre> or C<textarea> element, white space characters are handled
as in the preserve state.  Otherwise, white space handling is same as
the parent element, if any.  If there is no parent element, the trim
state, if the result document is HTML, or the preserve state, if the
result document is plain text.

Example.

  <p>
    <t:text value=1234>
  </p>

... generates:

  <p>1234</p>

... while:

  <p t:space=preserve>
    <t:text value=1234>
  </p>

... generates:

  <p>
    1234
  </p>

Example.

  <p>
    <t:attr name="'class'" value=$class>
    <t:attr name="'title'" value=$title>
    Content

... generates:

  <p class="classname" title="titletext">Content</p>

White space characters before and after C<t:attr> elements are
ignored.

=head1 Conditional and repetition processing

Following elements can be used to control how and when a chunk of
nodes are processed.

=head2 <t:if x="{expr}">{content}(<t:elsif x="{expr}">{content})*[<t:else>{content}]</t:if>

The C<t:if> element specifies that its content should be conditionally
processed.  The element may be used anywhere in the C<html> element
(or its descendant).

The C<t:if> element can contain zero or more nodes that would be
allowed if the C<t:if> element were replaced by them, which are
referred to as the C<t:if> clause nodes.  Then, they can be followed
by zero or more sequence of C<t:elsif> elements immediately followed
by zero or more nodes that would be allowed if the C<t:if> element
were replaced by them, which are referred to as the C<t:elsif> clause
nodes.  Finally, there can be the C<t:else> element followed by zero
or more nodes that would be allowed if the C<t:if> element were
replaced by them, which are referred to as C<t:else> clause nodes.

If the condition specified by the C<t:if> element is met, the C<t:if>
clause nodes are processed.  Otherwise, if the condition specified by
a C<t:elsif> element is met, the corresponding C<t:elsif> clause nodes
are processed.  If there are multiple C<t:elsif> elements, the first
matching element's sibling nodes are processed.  If none of C<t:if>
and C<t:elsif> elements' conditions is met, and if there is the
C<t:else> element child, the C<t:else> clause nodes are processed.
The C<t:space> attribute of C<t:if>, C<t:elsif>, and C<t:else>
elements apply to their corresponding clause nodes.

The C<t:if> element and the C<t:elsif> element must have the C<x>
attribute.  The C<x> attribute is a Perl code expression attribute.
It represents the condition for the element.

The C<t:elsif> element and the C<t:else> element are void elements,
i.e. they have no end tag by default.

Example.

  <p>
    <t:if x="$foo > 100">
      100+
    <t:elsif x="$foo > 50">
      <strong><t:text value=$foo></strong>
    <t:else>
      <t:text value=$foo>
    </t:if>

=head2 <t:for as="{varname}" x="{expr}">{content}</t:for>

The C<t:for> element specifies that the content should be processed
multiple times.  The element may be used anywhere in the document
element (or its descendant).

The C<x> attribute must be specified.  The attribute is a Perl
expression attribute.  The expression must return a value, which can
be evaluated as if it were an array reference (i.e. a plain or tied
array reference, a blessed array reference, or an object whose C<@{}>
operation is overloaded).  The content of the C<t:for> element is
processed with each item in the array, in same order.

The C<as> attribute specifies the name of the lexical variable to
which the array item for the current iteration is bound during the
processing of the content.  The syntax of the attribute value is same
as the C<as> attribute of the C<t:my> element.

The content of the C<t:for> element must be nodes that would be
allowed if the C<t:if> element were replaced by them (but may be
followed by C<t:sep> element as described below).

Example.

  <ul>
    <t:for as = $v x = "[1, 5, 10]">
      <li><t:text value="$v * 2">
    </t:for>
  </ul>

... generates:

  <ul><li>2</li><li>10</li><li>20</li></ul>

The C<t:sep> element can be used as a child of the C<t:for> element.
If there is the element, nodes following the element is used as
separator between iterations of the C<t:for> element processing.  The
C<t:sep> element is a void element, i.e. it has no end tag by default.
The C<t:space> attribute of the C<t:sep> element applies to nodes
following the element.  Nodes following the C<t:sep> element must be
nodes that would be allowed if the C<t:if> element were replaced by
them.

Example.

  <p>
    <t:for as=$x x="[1..5]">
      <t:text value=$x>
    <t:sep>
      <t:text value="', '">
    </t:for>

... generates:

  <p>1, 2, 3, 4, 5</p>

The C<t:next> element and the C<t:last> element can be inserted as
child or descendant of the C<t:for> element (before the C<t:sep>
element).  Like the Perl statements with same name, these elements
stop the processing of the current iteration and jump to the next
iteration or exit the processing of the C<t:for> loop.  The C<t:for>
element can be named by the C<name> attribute.  The attribute, if
specified, must have a non-empty string.  Elements C<t:next> and
C<t:last> can have the C<for> attribute to identify the C<t:for> block
by its name.  The C<for> attribute value must be the non-empty string
identifying a C<t:for> block in scope.  The C<t:next> element and the
C<t:last> element are void elements, i.e. they have no end tag by
default.

Example.

  <div>
    <t:for as=$v x="[1..10]">
      <t:text value=$v><t:if x="$v > 5"><t:last></t:if>
    </t:for>
  </div>

... generates:

  <div>123456</div>

=head2 <t:try>{content}(<t:catch [package="{package}"]>{content})*</t:try>

The C<t:try> element and the C<t:catch> element can be used to catch
exceptions.  The element may be used anywhere in the C<html> element
(or its descendant).

The C<t:try> element can contain nodes that would be allowed if the
C<t:try> element were replaced by them.  These nodes are processed
first.  The C<t:space> attribute is applied to them.  These nodes can
be followed by one or more sequence of the C<t:catch> element and zero
or more nodes.  Those nodes, again, must be nodes that would be
allowed if the C<t:try> element were replaced by them.  The C<t:catch>
element is a void element, i.e. it has no end tag by default.  The
C<t:space> attribute of the C<t:catch> element is applied to the nodes
following that element (but not by another C<t:catch> element).

If the C<t:try> element's first nodes are processed, and an exception
is thrown by the process, the C<t:catch> clauses are tested (in tree
order) to find an applicable one.  If there is one, that clause is
then processed.  Otherwise, the exception is rethrown.  The C<t:catch>
clauses match to an exception if no C<package> attribute is specified
to the element or the C<package> attribute is specified and the
exception object is an instance of the package identified by the
C<package> attribute value.

In Perl, an exception can be thrown by invoking the C<die> statement.
At the time of writing, only evaluaton of Perl expression attributes
can cause an exception thrown in the Temma language.

The C<t:catch> element may have the C<as> attribute.  The C<as>
attribute specifies the name of the lexical variable to which the
exception is bound during the processing of the clause.  The syntax of
the attribute value is same as the C<as> attribute of the C<t:my>
element.

Example.

  <p>
    <t:try>
      <t:call x=" die (My::Exception->new) ">
    <t:catch as=$x package="My::Exception">
      My::Exception!
    </t:try>

=head2 <t:wait cv="{expr}" [as="{varname}"]>

The C<t:wait> element waits for the specified condition being met.  It
suspends the temma template processing until the callback function is
invoked.  The element may be used anywhere in the C<html> element (or
its descendant).  The C<t:wait> element is a void element, i.e. it has
no end tag by default.

The C<cv> attribute of the C<t:wait> element is a Perl expression
attribute.  The C<cv> attribute is required.  It must return an
object.  The returned object is expected to be a condvar object.

The C<as> attribute specifies the name of the lexical variable to
which the value returned by the C<recv> method of the condvar object
is bound during the processing of the clause.  The syntax of the
attribute value is same as the C<as> attribute of the C<t:my> element.

Example:

  <t:my as=$cv>
  <t:call x="
    use AnyEvent;
    $cv = AE::cv;
    my $old_time = time;
    my $timer; $timer = AE::timer 2, 0, sub {
      undef $timer;
      $cv->send (time - $old_time);
    };
  ">
  <p>Before wait</p>
  <t:wait cv=$cv as=$sleep>
  <p>After wait (delta = <t:text value=$sleep> seconds)</p>

This template generates the "Before wait" paragraph, then wait 2
seconds (or more), then generates the "After wait" paragraph.

=head2 The condvar object

The C<t:wait> element expects the L<AnyEvent> condvar object, i.e. the
instance of the L<AnyEvent::CondVar> class.  The object must at least
have the C<cb> method, which takes an argument, which expects a code
reference.  The method should not throw any exception.  The method is
expected to invoke the code reference received as the argument when
(and only when) the Temma processor should resume the template
processing (exactly once).  The callback might or might not be invoked
synchronously within the C<cb> function.

The callback function specified as the argument to the C<cb> method is
expected to be invoked with an argument, which is expected to be an
object which has the C<recv> method.  The method is expected to return
a value, which is the value bound to the variable.  Temma will not
specify a function that intentionally throw an exception as the
argument to the C<cb> method.

=head1 Macros and inclusions

The Temma language has two mechanisms to reuse a template fragment:
macros and inclusions.  This section also describes how to receive
parameters from outside (or the invocant) of the template.

=head1 <t:macro name="{name}" t:params="{params}">{content}</t:macro>

The C<t:macro> element defines a macro with the specified name.  The
element may be used anywhere in the C<html> element (or its
descendant).  The element may contain any content.  The element
content is not processed when the C<t:macro> element is processed, but
instead it is registered as a macro available for the current template
processing.  Note that a macro cannot be invoked before it is
registered.

The C<t:macro> element must have the C<name> attribute, which defines
the name of the macro.  The macro name must be a string matching
regular expression C<[A-Za-z][A-Za-z0-9_-]*>.  The macro name is ASCII
case-insensitive.  The macro name must be unique; If a template
processing finds more than one C<t:macro> elements with same name,
only the first C<t:macro> element is registered as a macro.

Invocation of the macro and use of parameters are described in
following subsections.

Example.

  <t:macro name=hoge1>
    <div class=construct1>
      <p>Hoge
      <p>Fuga
    </div>
  </t:macro>

Please note that macro is I<not> a closure.  In particular, elements
in the macro cannot access lexical variables declared outside of the
C<t:macro> element.

=head2 <m:{name} {args}>{fields}</m:{name}>

The C<m:{name}> element, where C<{name}> is a macro name, represents
the insertion point for the macro.  The macro's content is processed
in the context of the element.  The local name of the element must be
the name of a macro defined before the element.  The element may be
used anywhere in the C<html> element (or its descendant).  The
specified macro is expected to generate nodes that are appropriate at
the insertion point.

Attributes and content can be used to specify arguments and fields for
the macro.  See later subsections for details.

=head2 <t:include path="{path}" {args}>{fields}</t:include>

The C<t:include> element represents the inclusion of a template
fragment contained in another file.  The parsed DOM tree for the file
is processed in the context of the element.  The element may be used
anywhere in the C<html> element (or its descendant).  The specified
file's content is expected to generate nodes that are appropriate at
the insertion point.

The C<t:incldue> element must have the C<path> attribute, whose value
represents the path to the file to include, relative to the file in
which the C<t:include> element appears.  Syntax of the file path
depends on the platform.

Attributes and content can be used to specify arguments and fields for
the included file.  See later subsections for details.

If the C<t:include> element is the child of the C<html> element, the
included file's content is parsed in the same way as a single source
document.  Otherwise, the C<t:include> element is not the child of the
C<html> element, the included file's content is parsed in the C<body>
parsing mode.  In the C<body> parsing mode, the template is parsed as
if there ere C<body> start tag before the first character of the
template.  The template parsed in the C<body> parsing mode cannot
contain C<body> start and end tags.  There may be the DOCTYPE at the
beginning of the template.  After the DOCTYPE, if any, there may be
the C<html> start tag with the C<t:params> attribute.

Example.

  <!DOCTYPE html>
  <t:include path="wrapper.html.tm">
    <p>Paragraph
  </t:include>

... and C<wrapper.html.tm>:

  <!DOCTYPE html>
  <title>My Web site</title>
  <body>
    <h1>My Web site</h1>
    <article><t:content></article>
  </body>

... generates:

  <!DOCTYPE html><html><head><title>My Web site</title></head>
  <body><h1>My Web site</h1>
    <article><p>Paragraph</p></article></body></html>

=head2 Attributes t:params="{params}" and m:{name}="{expr}"

Template documents and macros can declare parameters to them by using
the C<t:params> attribute.  For template documents, the attribute may
be specified to the C<html> element.  For macros, the attribute may be
specified to the C<t:macro> element.  Parameters can be used as
lexical variables whose scope is the document or the macro.  Parameter
values can be assigned by specifying arguments to the template
document or the macro by specifying the method to process the
template, by specifying attributes to the C<t:include> element, or by
specifying attributes to the C<m:{name}> element.

The attribute, if specified, must have a value consist of zero or more
variable names (see C<t:my> element's C<as> attribute's description),
separated by white space characters.  A variable name may be followed
by a question mark (C<?>), denoting the parameter is optional.  No
duplicate variable names within an attribute is allowed.

Example.  Given the outermost source document:

  <!DOCTYPE html>
  <html t:params="$name">
  <title>Document</title>
  <p><t:text value=$name>

... and arguments C<< {name => 'Jon Smith'} >>, the result document
will be:

  <!DOCTYPE html><html><head><title>Document</title></head>
  <body><p>Jon Smith</p></body></html>

The C<m:{varname}> attribute, where {varname} is the name of a
parameter, specifies the argument to the macro or included template.
The attribute can be specified to the C<m:{name}> element or the
C<t:include> element.  The attribute is a Perl expression attribute.
The evaluated value, possibly C<undef>, is used as argument to the
macro or the inclusion.

Example.

  <!DOCTYPE html>
  <title>Macro example</title>
  <t:macro name=title t:params="$title $prefix?">
    <h1>
      <t:text value="$prefix || '#'">.
      <t:text value="$title">
    </h1>
  </t:macro>
  <body>
  <m:title m:title="'Hello'"/>

... generates:

  <!DOCTYPE html><html><head><title>Macro example</title></head>
  <body><h1>#.
      Hello</body></html>

=head2 <t:field [name="{name}"]>{content}</t:field> and <t:content [name="{name}"]>

When a macro or an external file is inserted, zero or more bags of
nodes can be passed as "fields".

Any non white space characters and child nodes in the C<m:{name}>
element and the C<t:include> element implies the C<t:field> start tag.
Content of these elements must be zero or more C<t:field> elements.
The end tag of the C<t:field> element may be omitted.

Example.  Following lines are equivalent:

  <m:macro1>Hoge</m:macro1>
  <m:macro1><t:field>Hoge</m:macro1>
  <m:macro1><t:field>Hoge</t:field></m:macro1>

Fields have names.  If there is the C<name> attribute, its value is
used as the name.  The name must be a non-empty string.  Otherwise, a
sequential number is assinged as the name in document order.  There
must not be duplicate field names for the same macro or inclusion.

Example.  Following lines are equivalent:

  <m:macro2><t:field name=title>Hoge<t:field>1<t:field>2</m:macro2>
  <m:macro2><t:field>1<t:field>2<t:field name=title>Hoge</m:macro2>
  <m:macro2>1<t:field>2<t:field name=title>Hoge</m:macro2>

The C<t:field> element may contain any content.

The C<t:content> element can be used anywhere in the document to
process the nodes in the field of the macro or the inclusion.  The
C<name> attribute identifies the field name to process.  If the
attribute is not specified, the C<1> field is processed.  If there is
no field with the specified name, or if the element is used outside of
a macro and the document is not included in another document, the
element is ignored.  The C<t:content> element is a void element,
i.e. it has no end tag by default.

Example.

  <title>Macro field example</title>
  <t:macro name=section>
    <section>
      <h1><t:content name=title></h1>
      <t:content>
    </section>
  </t:macro>
  <body>
  <m:section>
    <t:field name=title>Section 1
    <t:field>
      <p>Para 1
      <p>Para 2
  </m:section>

... generates:

  <!DOCTYPE html><html><head><title>Macro field example</title></head>
  <body><section><h1>Section 1</h1><p>Para 1</p><p>Para 2</p></section></body></html>

=head1 Integration with text catalog

The Temma language has builtin support for integration with text
message catalog, which enables internationalization of texts within
template.

The text messages in the text message cataglog is identified by the
pair of the B<Message set> and the C<Message ID>.  The application
which uses the text catalog feature must specify the B<locale object>
for the template processing.  The locale object provides the access to
the message catalog.

The locale object is responsive to determine the language in use or to
load the appropriate message catalog set.  How to specify the locale
object for the processing, and the interface the locale object must
implement, are described in the documentation for the
L<Temma::Processor>.

=head2 <msg:{msgid}>{fields}</msg:>

The C<msg:{msgid}> element can be used to generate node(s) from the
specified message ID and the text message catalog in use.

The local name of the element specifies the message ID.  It can
contain ASCII lowercase letters, ASCII digits, C<->, C<_>, and C<.>.
The first character must be one of ASCII lowercase letters.

Example:

  <msg:myapp.title/>

... generates a text node whose value is the text corresponding to the
message ID C<myapp.title> in the default message set.

Content of the element can be used to specify fields for the message.
See previous subsections for details.  Any field is used as argument
to the text message.

The C<n> attribute is a Perl expression attribute.  If specified, the
evaluated value must be a number.  The number is used to choose the
variation of the text message (plural or singular for many Western
languages; there could be more or no variant for other languages).  If
the attribute is not specified, the number is not defined (which is
different from 0, 1, or any other number).

Example:

  <msg:items_n n="$items->length">
    <t:text value="$items->length">
  </msg:>

This fragment generates the text node whose value is the text
corresponding to the message ID C<person_n> in the default message
set, with the field named C<1> whose value is the C<t:text> element.
Given the text for the ID is defined as C<an item> if C<n = 1> and
C<%1 items> otherwise (where C<%1> indicates insertion of the field
with name C<1>), the value is one of C<an item>, C<2 items>, C<3
items>, ... depending on the value of the C<n> attribute, i.e. C<<
$items->length >>.

Within the fields for the C<msg:{msgid}> element, the lexical variable
C<$n> can be used to refer to the evaluated value of the C<n>
attribute value.  If there is no C<n> attribute, the variable is bound
to the C<undef> value.

Example: The previous example can be rewrite as:

  <msg:items_n n="$items->length">
    <t:text value=$n>
  </msg:>

The message set of the text message referred to by the element is the
I<default message set>.  This can be overridden by specifying the
C<set> attribute.  The value must be the name of a string identifying
the message set accessible from the locale object.

Example:

  <msg:help.usage.p1 set="My::Blog"/>
  <msg:help.usage.p1 set="My::Bookmark"/>

... generates the text node representing a paragraph for the help
contained in the C<My::Blog> and C<My::Bookmark> message set,
representively.  Although these elements share the same message ID,
since they belong to different message set, their corresponding texts
can be different (depending on the locale object's implementation).

The message ID should be the one defined in the message text catalog.
However, if there is no text defined for the specified message ID, the
C<msg:{msgid}> element still generates a text node.  The value of the
text node is the value of the C<alt> attribute, if any.  If there is
no C<alt> specified, the message ID itself is uesd as the value
instead.  The C<alt> attribute is optional.  If specified, the value
is expected to be the text corresponding to the message ID of the
element in some language.  The C<alt> attribute value is intended to
be the advisory information for template authors, as message ID is
likely unreadable stupid string such that editing the template could
be difficult without such guidance.  Additionally, the C<alt>
attribute value would be useful for extracting initial message ID /
text mapping table from templates in earlier stage of development.

The C<barehtml> attribute is a boolean attribute.  Unless the
attribute is specified, the text corresponding to the message ID is
embedded as part of text nodes.  If the attribute is specified, and if
the string (or part of strings) is marked as bare HTML fragment, then
the string is handled as mixture of texts and HTML markup, like the
value of the C<t:barehtml> element.  Similar to the C<t:barehtml>
element, the C<barehtml> should also be avoided where possible.

Example:

  <p><msg:first barehtml />: ...</p>

If the locale object for the processor provides HTML fragment C<<
1<sup>st</sup> >> for the message ID C<first>, this template
generates:

  <p>1<sup>st</sup>: ...</p>

=head2 Attribute msg:{name}="{msgid}"

The C<msg:{name}> attribute, where {name} is the attribute local name,
can be used to generate an attribute for the result element generated
by the nearest ancestor source element generating an element.  It may
be specified for an element which generates an element.  The attribute
value is interpreted as a message ID in the default message set.

Unlike the C<msg:{msgid}> element, the local name is interpreted as
the name of the attribute.  The message ID is represented as the
attribute value instead.  There is no syntax corresponding to C<n>,
C<set>, C<alt>, and C<barehtml> attributes.  No argument (or field)
can be specified for the attribute.

As described in previous sections, duplicate attributes,
i.e. attributes with same names, must not be generated by the
C<msg:{name}> attribute.

Example:

  <h1><img src=sitename.png msg:alt=sitename></h1>

The C<img> element in the result document has the C<alt> attribute
whose value is the text message corresponding to the message ID
C<sitename> in the default message set.

=head1 SEE ALSO

L<Temma>, L<Temma::Parser>, L<Temma::Processor>.

HTML Living Standard <http://c.whatwg.org/>.

=head1 AUTHOR

Wakaba <w@suika.fam.cx>.

=head1 LICENSE

Copyright 2012 Wakaba <w@suika.fam.cx>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
