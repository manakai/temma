=head1 NAME

Temma::Language - Temma template markup language

=head1 SYNOPSIS

  <!DOCTYPE html>
  <html lang=en t:params=$paras>
  <title>A Temma template</title>
  
  <h1>Temma language</h1>
  
  <t:for as=$para x=$paras>
    <p><t:text value=$para>
  </t:for>

=head1 DESCRIPTION

The B<Temma markup language> is an HTML-based template document format
for generating HTML or plain text documents.  This document describes
the syntax and semantics of the markup language.

The language and its processing model is defined in terms of DOM tree.
Syntactical components of the template is represented as DOM nodes in
the document.  There is the serialized format for the language, whose
syntax is mostly inspired by HTML serialization format of the HTML
language.  The B<Temma parser> is a software component to read the
serialized format into the DOM representation of the Temma markup
language.  The B<Temma processor> is a software component to convert
DOM of the source (template) document into result document.

 +---------------------+  <!DOCTYPE html>
 | Source document     |  <html t:params=$foo>
 | (template)          |  <title>Test</title>
 | in Temma syntax     |  <p><t:text value=$foo>
 +---------------------+
           |
           | Parse
           v
 +---------------------+  #document
 | DOM of source       |   +- html
 | (template) document |    +- head - title - #text
 +---------------------+    +- body - p - t:text
           |
           | Process
           v
 +---------------------+  #document
 | DOM of              |   +- html
 | result document     |    +- head - title - #text
 +---------------------+    +- body - p - #text
           |
           | Serialize
           v
 +---------------------+  <!DOCTYPE html>
 | Result document     |  <html><head><title>Test</title></head>
 | in HTML syntax      |  <body><p>Paragraph.</p></body></html>
 +---------------------+

=head1 Basic rules and handling of HTML nodes

The Temma syntax shares most syntax and parsing rules with the HTML
syntax.  That is, most of conforming HTML documents result in same DOM
tree by both HTML and Temma parsers.  (See
<http://www.whatwg.org/specs/web-apps/current-work/#syntax> for
details of the HTML syntax.)

The document node created by the Temma parser is marked as an HTML
document for the purpose of DOM
<http://dom.spec.whatwg.org/#html-document>.  (This may affect
conformance of the document.  For example, the C<lang> attribute
rather than the C<xml:lang> attribute must be used to encode the
language of an HTML element.)

Nodes in the source (i.e. template) document are processed in document
order to generate the result document.

The document node in the source document generates the document node
in the result document and its child nodes are processed to generate
children of the result document.

The source document may contain the DOCTYPE whose name is C<html>.
This is optional; the Temma parser implies the DOCTYPE anyway.  The
document type node in the source document generates the document type
node in the result document with same name.

HTML, SVG, and MathML element nodes in the source document result in
element nodes with same namespace and local name in the result
document, and their attributes and child nodes are also processed to
generate attributes and children of the result element.

The document element (or root element of the document) must be the
HTML C<html> element.

As in the HTML syntax, some of start and end tags can be omitted in
the Temma syntax.  Although how omissions are interpreted by the Temma
parser differs from the HTML parser in several ways, as long as
conforming document fragment goes, both HTML and Temma parser should
generate same DOM tree for an input.

Example.  Two lines below are equivalent:

  <!DOCTYPE html><title>fuga</title><p>hoge<p>hoge
  <!DOCTYPE html><html><head><title>fuga</title><body><p>hoge</p><p>hoge</p></body></html>

For the source element in HTML, SVG, or MathML namespace, any
attribute with no namespace, or in C<xml:>, C<xmlns:>, or C<xlink:>
namespace, generates an attribute with same namespace, local name, and
value, for the result element generated by the source element.

Example.  A template:

  <html lang=ja><title>Hello</title><p title="A paragraph.">Hello, world!

... generates the following result document:

  <!DOCTYPE html><html lang="ja"><head><title>Hello</title></head>
  <body><p title="A paragraph.">Hello, world!</p></body></html>

The Temma syntax does not support XML Namespaces, but there are
namespace prefix syntax for embedding Temma template instructions.
For example, tag name C<t:if> represents the C<if> element in the
Temma namespace.  Likewise, attribute name C<m:param1> represents the
C<param1> attribute in the Temma macro namespace.  There are following
namespace prefixes:

  t:      Temma namespace
  m:      Temma macro namespace
  msgid:  Temma message ID namespace
  pl:     Temma Perl code namespace

=head1 Processing of element content

The content of a source element is processed in document order.  A
text node might generate text node in the result document.  An element
in HTML, SVG, or MathML namespace generates an element in the result
document.  An element in Temma or Temma macro namespace is handled by
their processing rules.  Other types of nodes, including comment,
CDATA section, and processing instruction nodes, are ignored.

Void elements in the HTML syntax are also void elements in the Temma
syntax, i.e. their end tags must be omitted.

Example.  Following elements cannot have end tags and contents:

  <br>
  <img src="foo.png" alt="Foo Image">

Unlike the HTML syntax, the polytheistic slash syntax can be used to
represent an element with no content, even for HTML elements.  This
cannot be overridden by the C<t:parse> attribute described in the
following subsection.

Example.  Two lines below are equivalent:

  <div/><svg><g/></svg><p/><br/>
  <div></div><svg><g></g></svg><p></p><br>

As in the HTML syntax, no child element is allowed within following
HTML elements: C<title>, C<textarea>, C<style>, and C<script>.

Example.  The following C<script> element contains only a text node:

  <script> document.getElementById ('hoge').innerHTML = '<p>hoge</p>' </script>

Character references allowed in the HTML syntax are also allowed in
element content and attribute value of the Temma syntax, except for
content of C<style> and C<script> elements.

Examples.  Following lines represent paragraphs with same text, i.e. a
string with 5 characters, C<Q & A>:

  <p>Q & A</p>
  <p>Q &amp; A</p>
  <p>Q &#x26; A</p>
  <p>Q &#38; A</p>

... but the following script contains string literal with 9 characters
C<Q &amp; A>.

  <script>var a = 'Q &amp; A';</script>

=head2 Attribute t:parse=""

Any element may have C<t:parse=""> boolean attribute to override
element-dependent special content parsing behavior.  If the attribute
is specified for the element, its content is parsed in the same way as
a normal element, i.e. child elements and character references are
recognized and the end tag is required for the void element.

Example.  The following C<title> element contains a C<t:text> element
as a child:

  <title t:parse>
    <t:text value=" $title "> - My Web site
  </title>

If there were no C<t:parse> attribute, the C<t:text> tag is
interpreted as part of the only text node in the C<title> element (the
C<< < >> character is interpreted as part of the text).

Example.  The following C<img> element contains a C<t:attr> element as
a child:

  <img t:parse>
    <t:attr name="'src'" value=$image_url>
    <t:attr name="'alt'" value=$image_text>
  </img>

=head1 Evaluation of Perl code

Some of attributes is defined as Perl expression attributes.  Their
values are evaluated during the processing of the template.

A Perl expression attribute value is evaluated as if it were enclosed
by a Perl block (i.e. C<do { ... };>) and under the C<use strict; use
warnings;> pragmata.  Since each attribute value is evaluated
independently, any lexical variable declared within an attribute
cannot be used in another attribute.  As all Perl expressions in the
template is evaluated in the context of a specific (dynamically
generated) package, attributes can share a variable by using the
C<our> statement:

  <!-- ! This is not the preferred way to share a variable ! -->
  <t:call x="our $hoge = 124">
  <t:text value="our $hoge">

However, the C<t:my> element described in the next subsection is more
recommended way to share variables among Perl expression attributes.

Most of Perl expression attributes are expected to return a value.  If
the code explicitly return a value by the C<return> statement, it is
the value returned by the expression.  Otherwise, the last evaluated
value is the returned value.  When a string value is expected to be
returned, it must be a character string.  In other word, if the string
contain a character greater than U+00FF, the string must be
utf8-flagged.

=head2 <t:my as="{varname}" [x="{expr}"]>

The C<t:my> element declares a lexical variable.  The C<t:my> element
is a void element, i.e. it has no end tag by default.  The C<t:my>
element may be inserted anywhere in the document.

The C<as> attribute is required.  Its value must be a valid variable
name specification, i.e. a string matching the regular expression
C<\$[A-Za-z][A-Za-z0-9_]*> but not C<$_>.  The C<$> prefix may be
omitted.  The C<as> attribute is the variable name to be declared.

The C<x> attribute is a Perl expression attribute.  If specified, the
evaluated value of the attribute is assigned to the variable declared
by the element.  Otherwise, the C<undef> value is assigned.

The scope of the variable declared by the C<t:my> element is the
following sibling nodes and their children, except for any descendant
C<t:macro> element and its children.

Example.

  <div>
    <t:text value=" $foo * 1 "><!-- Syntax error -->
    <t:my as=$foo value=120>
    <t:text value=" $foo * 2 "><!-- 240 -->
    <p>
      <t:text value=" $foo * 3 "><!-- 360 -->
      <t:my as=$foo value=50>
      <t:text value=" $foo * 4 "><!-- 200 -->
  </div>
  <t:text value=" $foo * 5 "><!-- Syntax error -->

=head2 <t:call x="{expr}">

The C<t:call> element can be used to invoke a Perl code fragment
without using its result.  The element may be used anywhere in the
C<html> element (or its descendant).  The C<t:call> element is a void
element, i.e. it has no end tag by default.

The C<x> attribute is a Perl expression attribute.  The C<x> attribute
is required.  The Perl expression is evaluated when the element is
processed.  Otherwise the element does nothing.

=head1 Generating nodes in result document

As decribed in previous sections, HTML element nodes and text nodes
generate elements and texts in result document.  In addition,
following Temma elements can be used to generate nodes whoes values
are partially determined by evaluating Perl code.

=head2 <t:element name="{expr}">{content}</t:element>

The C<t:element> element generates an element, whose tag name is given
by the C<name> attribute.  The element may be used anywhere within the
HTML C<head> and C<body> elements (and their children) where child
elements are allowed in the result document.  The content of the
C<t:element> element is processed to generate the content of the
element.

The C<t:element> element must have the C<name> attribute, which is a
Perl expression attribute.  The expression must return a valid tag
name or the C<undef> value.

If the C<name> attribute is evaluated to a tag name, an element with
the tag name is generated.  The namespace of the generated element
depends on the nearest ancestor element which is not in the Temma
namespace in the source document.

Example.

  <svg>
    <t:element name="'g'">
      <circle/>
    </t:element>
  </svg>

The C<t:element> in the template fragment above generates an SVG C<g>
element as its parent element belongs to the SVG namespace.

If the C<name> attribute is evaluated to the C<undef> value, then no
element is generated from the C<t:element> element, although its
content is processed as if it were content of a normal element.  Any
C<t:attr> or C<t:class> child elements at the beginning of the
children list of the C<t:element> is ignored.

Example.

  <p>
    <t:element name=" defined $obj->url ? 'a' : undef ">
      <t:attr name="'href'" value=" $obj->url ">
      <t:text value=" $obj->label ">
    </t:element>

This template generates a paragraph whose content is the label of the
given object.  The label is linked to the URL of the object, if any,
using the HTML C<a> element:

  <p><a href="http://my.example.com/">Top page</a></p>

Otherwise, the label is directly contained within the C<p> element:

  <p>This page</p>

Note that the C<t:attr> element is ignored if the C<t:element> element
generates no element.  Also note that white space characters before
and after C<t:text> element are ignored even when the C<t:element>
element generates no element.

The C<t:element> element cannot be used to generate C<html>, C<head>,
or C<body> element.

=head2 <t:attr name="{expr}" value="{expr}">

The C<t:attr> element generates an attribute for the result element
generated by the nearest ancestor source element generating an
element.  The C<t:attr> element may be placed as a child of any
element, but it must be placed before any text node containing non
white space character or any node generating an element, text, or
comment node.  The C<t:attr> element is a void element, i.e. it has no
end tag by default.

The C<name> attribute is a Perl expression attribute.  The attribute
is required.  The expression must return a valid attribute name.

The C<value> attribute is a Perl expression attribute.  The attribute
is required.  The expression must return a string, possibly empty.

Attributes generated by C<t:attr> elements are merged with attributes
generated by attributes of the source element.  There must not be
duplicate attribute names (except for the C<class> attribute, as
decribed in the next subsection).

Example.

  <p onclick=" alert (1) ">
    <t:if x="defined $title">
      <t:attr name="'title'" value="$title">
    </t:if>
    <t:attr name="'id'" value="$id">
    Hello!
  </p>

If the template above is evaluated with appropriate C<$title> and
C<$id> values, result fragment would be as follows:

  <p onclick=" alert (1) " title="Title." id="para1">Hello!</p>

=head2 <t:class name="{expr}">

The C<t:class> element specifies class names for the element generated
by the nearest ancestor source element which generates an element.
The C<t:class> element must be placed before any other element or non
white space character is generated.  The C<t:class> element is void
element, i.e. end tag is not allowed in general.

The C<t:class> element specifies a class name for the result element
generated by the nearest ancestor source element generating an
element.  The C<t:class> element may be placed anywhere the C<t:attr>
element can be placed.  The C<t:class> element is a void element,
i.e. it has no end tag by default.

Unlike other attributes, the C<class> attribute is handled specially.
There may be more than one of the C<class> source attribute, C<t:attr>
elements generating C<class> attributes, and C<t:class> elements, for
a single result element.  Their values must be space-separated lists
of zero or more class names.  They are used to generate a single
C<class> attribute for the result element.

Example.

  <p class="default global">
    <t:if x=$selected>
      <t:class name='"selected"'>
    </t:if>
    <t:attr name="'class'" value="'para-' . $level">
    Paragraph.

This template fragment would generate the following HTML fragment (if
there are appropriate variable assignments):

  <p class="default global selected para-4">Paragraph.</p>

=head2 <t:text value="{expr}">

The C<t:text> element generates a text node with the specified value.
in general.  The element can be placed as child or descendant of
metadata content or the HTML C<body> element.  The C<t:text> element
is a void element, i.e. it has no end tag by default.

The element must have exactly one of C<value> and C<msgid> attributes.
Use of the C<msgid> attribute is described in later section.

The C<value> attribute is a Perl expression attribute.  The expression
must return a string.

As the element generates a text node, not just string used as element
content in the HTML syntax, the returned string don't have to be
HTML-escaped.  Characters are automatically escaped, if necessary,
when the result document is serialized in the HTML syntax.

Example.

  <p><t:text value="'See also <Q & A> section.'">

... generates:

  <p>See also &lt;Q &amp; A&gt; section.</p>

=head2 <t:comment>{content}</t:comment>

The C<t:comment> element generates a comment node in the result
document.  This element can be used anywhere in the C<html> element
(or its descendant).

Any real comment node in the source document is ignored, i.e. not
appers in the result document.  Real comment syntax is expected to be
used as notes for template authors.  Instead, the C<t:comment> element
can be used to generate comments for the result document.

The C<t:comment> element may contain any node, but it must only
generate one or more characters.  In particular, there must not be an
element generating elements, attributes, or comments.

Comments in the HTML syntax cannot contain substring C<-->.  If the
C<t:comment> element's content generates a string containing C<--> or
ends by C<->, a space character is inserted just after each C<->
character.

Example.

  <p>
  <!-- The following element generates a comment -->
  <t:comment>
    <t:text value="'Comment1 -- Comment2'">
  </t:comment>

... generates:

  <p><!--Comment1 - -  Comment2--></p>

=head2 <t:barehtml value="{expr}">

The C<t:barehtml> element is special in that it does not generate a
node in the result document tree but it generates a bare HTML
fragment, i.e. a sequence of HTML tags, comments, character
references, CDATA sections (in foreign content), and other characters,
to be embedded in the result document serialized in the HTML syntax.

The element can be placed as child or descendant of metadata content
or the HTML C<body> element.  The C<t:barehtml> element is a void element,
i.e. it has no end tag by default.

The element must have exactly one of C<value> and C<msgid> attributes.
Use of the C<msgid> attribute is described in later section.

The C<value> attribute is a Perl expression attribute.  The expression
must return a string, which is expected to be an HTML fragment valid
in the context of the position the fragment is inserted in the result
document.

This element should not be used, as the rules to construct the HTML
node structure of the result document should be fully described by the
Temma language, not in random Perl logic.  (This is the Separation of
Concerns principle for the Temma template processing, for
maintenancebility, security, and syntactical soundness.)  Neverthless
this element is provided such that something already formatted in
HTML, e.g. Markdown-converted HTML fragment or HTML document fragment
from external data source, can be easily integrated with the rest of
template.

Currently, the returned HTML fragment is inserted to the result
document as is, without any parsing.  This behavior is subject to
future change and the author should not rely on the current behavior.

=head2 Attribute t:space="{keyword}"

The C<t:space> attribute may be specified to any element.  The
attribute is an enumerated attribute whose keywords are C<preserve>
and C<trim>.  The attribute specifies how the white space in the
element content is handled.  The C<preserve> keyword maps to the
preserve state.  The C<trim> keyword maps to the trim keyword.  In
addition, there is a third state, the default state, which is the
missing value default.

By default, leading and trailing white space characters in an element
is ignored and do not appear in the result document.  Elements
C<t:attr> and C<t:if> are ignored for the purpose of detection of
leading and trailing white space characters.  However, this behavior
is not applied to HTML C<pre> and C<textarea> elements.  This white
space handling can be overridden by specifying the C<t:space>
attribute.

The preserve state of the C<t:space> attribute indicates that the
leading and trailing white space characters in an element generates
the same sequence of characters in the result document.  The trim
state indicates that the leading and white space characters in an
element should be ignored such that they do not apper in the result
document.  The default state indicates that, if the element is the
HTML C<pre> or C<textarea> element, white space characters are handled
as in the preserve state.  Otherwise, white space handling is same as
the parent element, if any.  If there is no parent element, the trim
state, if the result document is HTML, or the preserve state, if the
result document is plain text.

Example.

  <p>
    <t:text value=1234>
  </p>

... generates:

  <p>1234</p>

... while:

  <p t:space=preserve>
    <t:text value=1234>
  </p>

... generates:

  <p>
    1234
  </p>

Example.

  <p>
    <t:attr name="'class'" value=$class>
    <t:attr name="'title'" value=$title>
    Content

... generates:

  <p class="classname" title="titletext">Content</p>

White space characters before and after C<t:attr> elements are
ignored.

=head1 Conditional and repetition processing

Following elements can be used to control how and when a chunk of
nodes are processed.

=head2 <t:if x="{expr}">{content}(<t:elsif x="{expr}">{content})*[<t:else>{content}]</t:if>

The C<t:if> element specifies that its content should be conditionally
processed.  The element may be used anywhere in the C<html> element
(or its descendant).

The C<t:if> element can contain zero or more nodes that would be
allowed if the C<t:if> element were replaced by them, which are
referred to as the C<t:if> clause nodes.  Then, they can be followed
by zero or more sequence of C<t:elsif> elements immediately followed
by zero or more nodes that would be allowed if the C<t:if> element
were replaced by them, which are referred to as the C<t:elsif> clause
nodes.  Finally, there can be the C<t:else> element followed by zero
or more nodes that would be allowed if the C<t:if> element were
replaced by them, which are referred to as C<t:else> clause nodes.

If the condition specified by the C<t:if> element is met, the C<t:if>
clause nodes are processed.  Otherwise, if the condition specified by
a C<t:elsif> element is met, the corresponding C<t:elsif> clause nodes
are processed.  If there are multiple C<t:elsif> elements, the first
matching element's sibling nodes are processed.  If none of C<t:if>
and C<t:elsif> elements' conditions is met, and if there is the
C<t:else> element child, the C<t:else> clause nodes are processed.
The C<t:space> attribute of C<t:if>, C<t:elsif>, and C<t:else>
elements apply to their corresponding clause nodes.

The C<t:if> element and the C<t:elsif> element must have the C<x>
attribute.  The C<x> attribute is a Perl code expression attribute.
It represents the condition for the element.

The C<t:elsif> element and the C<t:else> element are void elements,
i.e. they have no end tag by default.

Example.

  <p>
    <t:if x="$foo > 100">
      100+
    <t:elsif x="$foo > 50">
      <strong><t:text value=$foo></strong>
    <t:else>
      <t:text value=$foo>
    </t:if>

=head2 <t:for as="{varname}" x="{expr}">{content}</t:for>

The C<t:for> element specifies that the content should be processed
multiple times.  The element may be used anywhere in the document
element (or its descendant).

The C<x> attribute must be specified.  The attribute is a Perl
expression attribute.  The expression must return a value, which can
be evaluated as if it were an array reference (i.e. a plain or tied
array reference, a blessed array reference, or an object whose C<@{}>
operation is overloaded).  The content of the C<t:for> element is
processed with each item in the array, in same order.

The C<as> attribute specifies the name of the lexical variable to
which the array item for the current iteration is bound during the
processing of the content.  The syntax of the attribute value is same
as the C<as> attribute of the C<t:my> element.

The content of the C<t:for> element must be nodes that would be
allowed if the C<t:if> element were replaced by them (but may be
followed by C<t:sep> element as described below).

Example.

  <ul>
    <t:for as = $v x = "[1, 5, 10]">
      <li><t:text value="$v * 2">
    </t:for>
  </ul>

... generates:

  <ul><li>2</li><li>10</li><li>20</li></ul>

The C<t:sep> element can be used as a child of the C<t:for> element.
If there is the element, nodes following the element is used as
separator between iterations of the C<t:for> element processing.  The
C<t:sep> element is a void element, i.e. it has no end tag by default.
The C<t:space> attribute of the C<t:sep> element applies to nodes
following the element.  Nodes following the C<t:sep> element must be
nodes that would be allowed if the C<t:if> element were replaced by
them.

Example.

  <p>
    <t:for as=$x x="[1..5]">
      <t:text value=$x>
    <t:sep>
      <t:text value="', '">
    </t:for>

... generates:

  <p>1, 2, 3, 4, 5</p>

The C<t:next> element and the C<t:last> element can be inserted as
child or descendant of the C<t:for> element (before the C<t:sep>
element).  Like the Perl statements with same name, these elements
stop the processing of the current iteration and jump to the next
iteration or exit the processing of the C<t:for> loop.  The C<t:for>
element can be named by the C<name> attribute.  The attribute, if
specified, must have a non-empty string.  Elements C<t:next> and
C<t:last> can have the C<for> attribute to identify the C<t:for> block
by its name.  The C<for> attribute value must be the non-empty string
identifying a C<t:for> block in scope.  The C<t:next> element and the
C<t:last> element are void elements, i.e. they have no end tag by
default.

Example.

  <div>
    <t:for as=$v x="[1..10]">
      <t:text value=$v><t:if x="$v > 5"><t:last></t:if>
    </t:for>
  </div>

... generates:

  <div>123456</div>

=head2 <t:try>{content}(<t:catch [package="{package}"]>{content})*</t:try>

The C<t:try> element and the C<t:catch> element can be used to catch
exceptions.  The element may be used anywhere in the C<html> element
(or its descendant).

The C<t:try> element can contain nodes that would be allowed if the
C<t:try> element were replaced by them.  These nodes are processed
first.  The C<t:space> attribute is applied to them.  These nodes can
be followed by one or more sequence of the C<t:catch> element and zero
or more nodes.  Those nodes, again, must be nodes that would be
allowed if the C<t:try> element were replaced by them.  The C<t:catch>
element is a void element, i.e. it has no end tag by default.  The
C<t:space> attribute of the C<t:catch> element is applied to the nodes
following that element (but not by another C<t:catch> element).

If the C<t:try> element's first nodes are processed, and an exception
is thrown by the process, the C<t:catch> clauses are tested (in tree
order) to find an applicable one.  If there is one, that clause is
then processed.  Otherwise, the exception is rethrown.  The C<t:catch>
clauses match to an exception if no C<package> attribute is specified
to the element or the C<package> attribute is specified and the
exception object is an instance of the package identified by the
C<package> attribute value.

In Perl, an exception can be thrown by invoking the C<die> statement.
At the time of writing, only evaluaton of Perl expression attributes
can cause an exception thrown in the Temma language.

The C<t:catch> element may have the C<as> attribute.  The C<as>
attribute specifies the name of the lexical variable to which the
exception is bound during the processing of the clause.  The syntax of
the attribute value is same as the C<as> attribute of the C<t:my>
element.

Example.

  <p>
    <t:try>
      <t:call x=" die (My::Exception->new) ">
    <t:catch as=$x package="My::Exception">
      My::Exception!
    </t:try>

=head2 <t:wait cv="{expr}" [as="{varname}"]>

The C<t:wait> element waits for the specified condition being met.  It
suspends the temma template processing until the callback function is
invoked.  The element may be used anywhere in the C<html> element (or
its descendant).  The C<t:wait> element is a void element, i.e. it has
no end tag by default.

The C<cv> attribute of the C<t:wait> element is a Perl expression
attribute.  The C<cv> attribute is required.  It must return an
object.  The returned object is expected to be an L<AnyEvent> condvar
object (i.e. an L<AnyEvent::CondVar> instance).  The object at least
has the C<cb> method, which takes an argument, which expects a code
reference.  The method should not throw any exception.  The method is
expected to invoke the code reference received as the argument when
(and only when) the temma processor should resume the template
processing (exactly once).  The callback might or might not be invoked
synchronously within the C<cb> function.  Temma will not specify a
function that intentionally throw an exception as the argument to the
C<cb> method.

The C<as> attribute specifies the name of the lexical variable to
which the value returned by the C<recv> method of the condvar object
is bound during the processing of the clause.  The syntax of the
attribute value is same as the C<as> attribute of the C<t:my> element.
The callback function specified as the argument to the C<cb> method is
expected to be invoked with an argument, which is expected to be an
object with the C<recv> method defined.  The method is expected to
return a value, which is the value bound to the variable.

Example:

  <t:my as=$cv>
  <t:call x="
    use AnyEvent;
    $cv = AE::cv;
    my $old_time = time;
    my $timer; $timer = AE::timer 2, 0, sub {
      undef $timer;
      $cv->send (time - $old_time);
    };
  ">
  <p>Before wait</p>
  <t:wait cv=$cv as=$sleep>
  <p>After wait (delta = <t:text value=$sleep> seconds)</p>

This template generates the "Before wait" paragraph, then wait 2
seconds (or more), then generates the "After wait" paragraph.

=head1 Macro and inclusions

XXX



=over 4

=item t:params="$var1 $var2 $optvar1? $optvar2?"

The C<t:params> attribute can be used to declare formal parameters of
the template or macro.  The attribute can be used on the C<html>
element or on the C<t:macro> element.

The attribute, if specified, must have a value consist of zero or more
variable names separated by white space characters.  A variable name
may be followed by a question mark (C<?>), denoting the parameter is
optional.  No duplicate variable names within an attribute is allowed.

XXX variable assignments

=back
